torch_tensor(unlist(train$y[itrain]))
),
valid_data = list(
torch_tensor(as.matrix(x_train_1h[ival, ]), dtype = torch_float()),
torch_tensor(unlist(train$y[ival]))
),
dataloader_options = list(batch_size = 512),
epochs = 10
)
fitted <- model %>%
fit(
# we transform the training and validation data into torch tensors
data = list(torch_tensor(x,dtype=torch_float()), torch_tensor(y)),
valid_data = list(
torch_tensor(as.matrix(x_train_1h[ival, ]), dtype = torch_float()),
torch_tensor(unlist(train$y[ival]))
),
dataloader_options = list(batch_size = 512),
epochs = 10
)
model <- nn_module(
initialize = function(input_size) {
self$hidden <- nn_linear(input_size, 16)
self$activation <- nn_relu()
self$dropout <- nn_dropout(0.2)
self$output <- nn_linear(16, 1)
},
forward = function(x) {
x %>%
self$hidden() %>%
self$activation() %>%
self$dropout() %>%
self$output() %>%
torch_flatten(start_dim = 1)
}
)
model <- model %>%
setup(
loss = nn_bce_with_logits_loss(),
optimizer = optim_rmsprop,
metrics = list(luz_metric_binary_accuracy_with_logits())
) %>%
set_opt_hparams(input_size = ncol(x))
fitted <- model %>%
fit(
# we transform the training and validation data into torch tensors
list(
torch_tensor(as.matrix(x_train_1h[itrain,]), dtype = torch_float()),
torch_tensor(unlist(train$y[itrain]))
),
valid_data = list(
torch_tensor(as.matrix(x_train_1h[ival, ]), dtype = torch_float()),
torch_tensor(unlist(train$y[ival]))
),
dataloader_options = list(batch_size = 512),
epochs = 10
)
model <- nn_module(
initialize = function(input_size) {
self$hidden <- nn_linear(input_size, 16)
self$activation <- nn_relu()
self$dropout <- nn_dropout(0.2)
self$output <- nn_linear(16, 1)
},
forward = function(x) {
x %>%
self$hidden() %>%
self$activation() %>%
self$dropout() %>%
self$output() %>%
torch_flatten(start_dim = 1)
}
)
model <- model %>%
setup(
loss = nn_bce_with_logits_loss(),
optimizer = optim_rmsprop,
metrics = list(luz_metric_binary_accuracy_with_logits())
) %>%
set_opt_hparams(input_size = ncol(x))
fitted <- model %>%
fit(
# we transform the training and validation data into torch tensors
list(
torch_tensor(as.matrix(x_train_1h[itrain,]), dtype = torch_float()),
torch_tensor(unlist(train$y[itrain]))
),
valid_data = list(
torch_tensor(as.matrix(x_train_1h[ival, ]), dtype = torch_float()),
torch_tensor(unlist(train$y[ival]))
),
dataloader_options = list(batch_size = 512),
epochs = 10
)
###
fitted <- modnn %>%
fit(
data = list(torch_tensor(x,dtype=torch_float()), torch_tensor(y)),
valid_data = list(torch_tensor(xtest,dtype=torch_float()), torch_tensor(ytest)),
dataloader_options = list(batch_size = 64),
epochs = 50
)
model <- nn_module(
initialize = function(input_size) {
self$hidden <- nn_linear(input_size, 16)
self$activation <- nn_relu()
self$dropout <- nn_dropout(0.2)
self$output <- nn_linear(16, 1)
},
forward = function(x) {
x %>%
self$hidden() %>%
self$activation() %>%
self$dropout() %>%
self$output() %>%
torch_flatten(start_dim = 1)
}
)
model <- model %>%
setup(
loss = nn_bce_with_logits_loss(),
optimizer = optim_rmsprop,
metrics = list(luz_metric_binary_accuracy_with_logits())
) %>%
set_opt_hparams(input_size = ncol(x))
###
fitted <- model %>%
fit(
data = list(torch_tensor(x,dtype=torch_float()), torch_tensor(y)),
valid_data = list(torch_tensor(xtest,dtype=torch_float()), torch_tensor(ytest)),
dataloader_options = list(batch_size = 64),
epochs = 50
)
model <- nn_module(
initialize = function(input_size) {
self$hidden <- nn_linear(input_size, 16)
self$activation <- nn_relu()
self$dropout <- nn_dropout(0.2)
self$output <- nn_linear(16, 1)
},
forward = function(x) {
x %>%
self$hidden() %>%
self$activation() %>%
self$dropout() %>%
self$output() %>%
torch_flatten(start_dim = 1)
}
)
###
modnn <- model %>%
setup(
loss = nn_bce_with_logits_loss(),
optimizer = optim_rmsprop,
metrics = list(luz_metric_binary_accuracy_with_logits())
) %>%
set_hparams(input_size = ncol(x))
###
fitted <- modnn %>%
fit(
data = list(torch_tensor(x,dtype=torch_float()), torch_tensor(y)),
valid_data = list(torch_tensor(xtest,dtype=torch_float()), torch_tensor(ytest)),
dataloader_options = list(batch_size = 64),
epochs = 50
)
model <- nn_module(
initialize = function(input_size) {
self$hidden <- nn_linear(input_size, 16)
self$activation <- nn_relu()
self$dropout <- nn_dropout(0.2)
self$output <- nn_linear(16, 1)
},
forward = function(x) {
x %>%
self$hidden() %>%
self$activation() %>%
self$dropout() %>%
self$output() %>%
torch_flatten(start_dim = 1)
}
)
model <- model %>%
setup(
loss = nn_bce_with_logits_loss(),
optimizer = optim_rmsprop,
metrics = list(luz_metric_binary_accuracy_with_logits())
) %>%
set_hparams(input_size = ncol(x))
fitted <- model %>%
fit(
# we transform the training and validation data into torch tensors
list(
torch_tensor(as.matrix(x_train_1h[itrain,]), dtype = torch_float()),
torch_tensor(unlist(train$y[itrain]))
),
valid_data = list(
torch_tensor(as.matrix(x_train_1h[ival, ]), dtype = torch_float()),
torch_tensor(unlist(train$y[ival]))
),
dataloader_options = list(batch_size = 512),
epochs = 10
)
fitted <- model %>%
fit(
# we transform the training and validation data into torch tensors
list(
torch_tensor(x, dtype = torch_float()), torch_tensor(y)),
valid_data = list(
torch_tensor(x, dtype = torch_float()), torch_tensor(y)),
dataloader_options = list(batch_size = 512),
epochs = 10
)
plot(fitted)
ynn <- {torch_sigmoid(predict(fitted,list(xtest, ytest))) > 0.5} %>% as.integer()
table(ynn,ytest)
mean(ynn==ytest)
model <- nn_module(
initialize = function(input_size) {
self$hidden <- nn_linear(input_size, 10)
self$activation <- nn_relu()
self$dropout <- nn_dropout(0.2)
self$output <- nn_linear(10, 1)
},
forward = function(x) {
x %>%
self$hidden() %>%
self$activation() %>%
self$dropout() %>%
self$output() %>%
torch_flatten(start_dim = 1)
}
)
model <- model %>%
setup(
loss = nn_bce_with_logits_loss(),
optimizer = optim_rmsprop,
metrics = list(luz_metric_binary_accuracy_with_logits())
) %>%
set_hparams(input_size = ncol(x))
fitted <- model %>%
fit(
# we transform the training and validation data into torch tensors
list(
torch_tensor(x, dtype = torch_float()), torch_tensor(y)),
valid_data = list(
torch_tensor(x, dtype = torch_float()), torch_tensor(y)),
dataloader_options = list(batch_size = 256),
epochs = 30
)
plot(fitted)
ynn <- {torch_sigmoid(predict(fitted,list(xtest, ytest))) > 0.5} %>% as.integer()
table(ynn,ytest)
mean(ynn==ytest)
x <- model.matrix(Direction~Lag1+Lag2-1,data=Smarket)[train,]
y <- as.numeric(Smarket$Direction[train])-1 #0 for Down, 1 for Up
xtest <- model.matrix(Direction~Lag1+Lag2-1,data=Smarket)[!train,]
ytest <- as.numeric(Smarket$Direction[!train])-1 #0 for Down, 1 for Up
model <- nn_module(
initialize = function(input_size) {
self$hidden <- nn_linear(input_size, 10)
self$activation <- nn_relu()
self$dropout <- nn_dropout(0.2)
self$output <- nn_linear(10, 1)
},
forward = function(x) {
x %>%
self$hidden() %>%
self$activation() %>%
self$dropout() %>%
self$output() %>%
torch_flatten(start_dim = 1)
}
)
model <- model %>%
setup(
loss = nn_bce_with_logits_loss(),
optimizer = optim_rmsprop,
metrics = list(luz_metric_binary_accuracy_with_logits())
) %>%
set_hparams(input_size = ncol(x))
fitted <- model %>%
fit(
# we transform the training and validation data into torch tensors
list(
torch_tensor(x, dtype = torch_float()), torch_tensor(y)),
valid_data = list(
torch_tensor(x, dtype = torch_float()), torch_tensor(y)),
dataloader_options = list(batch_size = 256),
epochs = 30
)
plot(fitted)
ynn <- {torch_sigmoid(predict(fitted,list(xtest, ytest))) > 0.5} %>% as.integer()
table(ynn,ytest)
mean(ynn==ytest)
x<- model.matrix(Direction~Lag1+Lag2+Lag3+Lag4+Lag5+Volume-1,data=Smarket)[train,]
y <- as.numeric(Smarket$Direction[train])-1 #0 for Down, 1 for Up
xtest <- model.matrix(Direction~Lag1+Lag2+Lag3+Lag4+Lag5+Volume-1,data=Smarket)[!train,]
ytest <- as.numeric(Smarket$Direction[!train])-1 #0 for Down, 1 for Up
model <- nn_module(
initialize = function(input_size) {
self$hidden <- nn_linear(input_size, 10)
self$activation <- nn_relu()
self$dropout <- nn_dropout(0.2)
self$output <- nn_linear(10, 1)
},
forward = function(x) {
x %>%
self$hidden() %>%
self$activation() %>%
self$dropout() %>%
self$output() %>%
torch_flatten(start_dim = 1)
}
)
model <- model %>%
setup(
loss = nn_bce_with_logits_loss(),
optimizer = optim_rmsprop,
metrics = list(luz_metric_binary_accuracy_with_logits())
) %>%
set_hparams(input_size = ncol(x))
fitted <- model %>%
fit(
# we transform the training and validation data into torch tensors
list(
torch_tensor(x, dtype = torch_float()), torch_tensor(y)),
valid_data = list(
torch_tensor(x, dtype = torch_float()), torch_tensor(y)),
dataloader_options = list(batch_size = 256),
epochs = 30
)
plot(fitted)
ynn <- {torch_sigmoid(predict(fitted,list(xtest, ytest))) > 0.5} %>% as.integer()
table(ynn,ytest)
mean(ynn==ytest)
setwd("C:/Users/hanis/OneDrive/Desktop/Y3S2/DSA3101/dsa3101-2220-10-rain/frontend")
gc()
require(telegram.bot)
source('./botFunctions.R')
setwd("C:/Users/hanis/OneDrive/Desktop/Y3S2/DSA3101/dsa3101-2220-10-rain/frontend")
require(telegram.bot)
source('./botFunctions.R')
setwd("C:/Users/hanis/OneDrive/Desktop/Y3S2/DSA3101/dsa3101-2220-10-rain/frontend/bot")
require(telegram.bot)
source('./botFunctions.R')
source('./locationFunctions.R')
source('./util.R')
# To run the bot, select all in this file and hit run.
# Then, open your telegram and send '/start'
# Use this link to access test bot: https://t.me/rainpredictor_testbot
# Am not sure what will happen if more than 1 person runs this at the same time tbh
# Functions are defined in botFunctions.R.
# Implementations we discussed should be done there.
# If your functions have a sub menu, or call additional functions,
# please create a separate R file and import them via source()
# Testing Bot access token
TOKEN <- "6283453880:AAGtUv5MlmZtbMxMZJL5HdYaD9QZv5pQ5sQ"
# Command names
# User will use these to access the commands
# for 'start', the user types '/start'
COMMAND_START <- 'start'
COMMAND_HELP <- 'help'
# initialises and adds commands to the Updater (which creates update objects)
updater <- Updater(token = TOKEN)
updater <- updater + CommandHandler(COMMAND_START, home) +
CommandHandler(COMMAND_HELP, rain_help)
# maps callbacks to the right function, throws an alert for invalid callbacks
general_callback_query <- function(bot, update) {
callback <- parse_callback_string(update$callback_query$data)
id <- callback$id
data <- callback$data
if (is_valid_cb_function(id, MAIN_FUNCTION_KEYS)) {
call_callback_function(id, MAIN_FUNCTION_KEYS, MAIN_CALLBACK_FUNCTIONS,
bot, update)
} else {
bot$answerCallbackQuery(update$effective_chat()$id,
'Callback data does not map to main functions',
show_alert = T)
}
}
location_callback_query <- function(bot, update) {
callback <- parse_callback_string(update$callback_query$data)
id <- callback$id
loc <- callback$data
if (is_valid_cb_function(id, LOC_FUNCTION_KEYS)) {
call_callback_function(id, LOC_FUNCTION_KEYS, LOC_FUNCTIONS,
bot, update)
} else {
bot$answerCallbackQuery(update$effective_chat()$id,
'Callback data does not map to location functions',
show_alert = T)
}
}
updater <- updater +
CallbackQueryHandler(general_callback_query, pattern="^general") +
CallbackQueryHandler(location_callback_query, pattern="^location")
# function to have the bot start listening to user input. if this is not
# run the bot does nothing
updater$start_polling()
require(telegram.bot)
source('./botFunctions.R')
source('./locationFunctions.R')
source('./util.R')
# To run the bot, select all in this file and hit run.
# Then, open your telegram and send '/start'
# Use this link to access test bot: https://t.me/rainpredictor_testbot
# Am not sure what will happen if more than 1 person runs this at the same time tbh
# Functions are defined in botFunctions.R.
# Implementations we discussed should be done there.
# If your functions have a sub menu, or call additional functions,
# please create a separate R file and import them via source()
# Testing Bot access token
TOKEN <- "6283453880:AAGtUv5MlmZtbMxMZJL5HdYaD9QZv5pQ5sQ"
# Command names
# User will use these to access the commands
# for 'start', the user types '/start'
COMMAND_START <- 'start'
COMMAND_HELP <- 'help'
# initialises and adds commands to the Updater (which creates update objects)
updater <- Updater(token = TOKEN)
updater <- updater + CommandHandler(COMMAND_START, home) +
CommandHandler(COMMAND_HELP, rain_help)
# maps callbacks to the right function, throws an alert for invalid callbacks
general_callback_query <- function(bot, update) {
callback <- parse_callback_string(update$callback_query$data)
id <- callback$id
data <- callback$data
if (is_valid_cb_function(id, MAIN_FUNCTION_KEYS)) {
call_callback_function(id, MAIN_FUNCTION_KEYS, MAIN_CALLBACK_FUNCTIONS,
bot, update)
} else {
bot$answerCallbackQuery(update$effective_chat()$id,
'Callback data does not map to main functions',
show_alert = T)
}
}
location_callback_query <- function(bot, update) {
callback <- parse_callback_string(update$callback_query$data)
id <- callback$id
loc <- callback$data
if (is_valid_cb_function(id, LOC_FUNCTION_KEYS)) {
call_callback_function(id, LOC_FUNCTION_KEYS, LOC_FUNCTIONS,
bot, update)
} else {
bot$answerCallbackQuery(update$effective_chat()$id,
'Callback data does not map to location functions',
show_alert = T)
}
}
updater <- updater +
CallbackQueryHandler(general_callback_query, pattern="^general") +
CallbackQueryHandler(location_callback_query, pattern="^location")
# function to have the bot start listening to user input. if this is not
# run the bot does nothing
updater$start_polling()
gc()
require(telegram.bot)
source('./botFunctions.R')
source('./locationFunctions.R')
source('./util.R')
# To run the bot, select all in this file and hit run.
# Then, open your telegram and send '/start'
# Use this link to access test bot: https://t.me/rainpredictor_testbot
# Am not sure what will happen if more than 1 person runs this at the same time tbh
# Functions are defined in botFunctions.R.
# Implementations we discussed should be done there.
# If your functions have a sub menu, or call additional functions,
# please create a separate R file and import them via source()
# Testing Bot access token
TOKEN <- "6283453880:AAGtUv5MlmZtbMxMZJL5HdYaD9QZv5pQ5sQ"
# Command names
# User will use these to access the commands
# for 'start', the user types '/start'
COMMAND_START <- 'start'
COMMAND_HELP <- 'help'
# initialises and adds commands to the Updater (which creates update objects)
updater <- Updater(token = TOKEN)
updater <- updater + CommandHandler(COMMAND_START, home) +
CommandHandler(COMMAND_HELP, rain_help)
# maps callbacks to the right function, throws an alert for invalid callbacks
general_callback_query <- function(bot, update) {
callback <- parse_callback_string(update$callback_query$data)
id <- callback$id
data <- callback$data
if (is_valid_cb_function(id, MAIN_FUNCTION_KEYS)) {
call_callback_function(id, MAIN_FUNCTION_KEYS, MAIN_CALLBACK_FUNCTIONS,
bot, update)
} else {
bot$answerCallbackQuery(update$effective_chat()$id,
'Callback data does not map to main functions',
show_alert = T)
}
}
location_callback_query <- function(bot, update) {
callback <- parse_callback_string(update$callback_query$data)
id <- callback$id
loc <- callback$data
if (is_valid_cb_function(id, LOC_FUNCTION_KEYS)) {
call_callback_function(id, LOC_FUNCTION_KEYS, LOC_FUNCTIONS,
bot, update)
} else {
bot$answerCallbackQuery(update$effective_chat()$id,
'Callback data does not map to location functions',
show_alert = T)
}
}
updater <- updater +
CallbackQueryHandler(general_callback_query, pattern="^general") +
CallbackQueryHandler(location_callback_query, pattern="^location")
# function to have the bot start listening to user input. if this is not
# run the bot does nothing
updater$start_polling()
